Copyright 1999, 2001, 2002, 2003 Free Software Foundation.
Contributed by the Spaces project, INRIA Lorraine.

This file is part of the MPFR Library.

The MPFR Library is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation; either version 2.1 of the License, or (at your
option) any later version.

The MPFR Library is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the MPFR Library; see the file COPYING.LIB.  If not, write to
the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
MA 02111-1307, USA.

##############################################################################

Probably many bugs.

Known bugs:

* The overflows/underflows are not yet implemented in all functions, or
  partially implemented. For instance, mpfr_pow (z, x, y, rnd) fails for
  very small x and some values of y.

* problem with tsqrt on ia64-hpux (problem is that variable a in check4 has
	a different value than in the call, may be a memory problem, since
	it disappears when we remove the mpfr_set_str instruction, and
	disappears without -O2)
mpfr_sqrt failed for a=4.15383748682786210282e+34, rnd_mode=GMP_RNDZ
expected 0.10010010111100001100100110000001011110111111001010000[00000000000]E53
got      0.10110101000001001111001100110011111110011101111001100[00000000000]E58

* texp fails on ia64-hpux: mpfr_exp_2 and mpfr_exp3 for prec=601

* acosh is wrong near EMAX (idem asinh):
   rounding mode GMP_RNDU:
      6096987078287.281250 ulp(s) for x=1.75062535692767808555e+308
      [mpfr: 7.097561817130842e2 libm: 7.10449328893644064919e+02]

Potential bugs:

* Possible integer overflows on some machines. Some types are used
  inconsistently.

* Possible infinite loop in some functions for particular cases: when
  the exact result is an exactly representable number or the middle of
  consecutive two such numbers.

* mpfr_set_d may give wrong results on some architectures.

* Error analysis in mpfr_sin is incorrect. A test has been added to
  show the bug. Check the other functions too...

* mpfr_hypot may fail for x very large, y very small and a very large
  target precision.

* Possible bugs related to the exponents. Compile with -DMPFR_EXP_CHECK
  and make check to see the potential problems (but in this case, don't
  be surprised if nothing is working!). This doesn't mean that the
  results may be incorrect though (a further analysis should be done
  and the code should be updated to avoid the failed assertions). As a
  consequence, MPFR_EXP_CHECK is not currently defined by default even
  when WANT_ASSERT is defined.
