\input texinfo    @c -*-texinfo-*-
@c %**start of header
@setfilename mpfr.info
@set VERSION 2.0.2
@set UPDATED-MONTH June 2002
@settitle MPFR @value{VERSION}
@synindex tp fn
@iftex
@afourpaper
@end iftex
@comment %**end of header

@copying
This manual documents how to install and use the Multiple Precision
Floating-Point Reliable Library, version @value{VERSION}.

Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
2003 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.1 or any later
version published by the Free Software Foundation; with no Invariant Sections,
with the Front-Cover Texts being ``A GNU Manual'', and with the Back-Cover
Texts being ``You have freedom to copy and modify this GNU Manual, like GNU
software''.  A copy of the license is included in @ref{GNU Free Documentation
License}.
@end copying


@c  Texinfo version 4.2 or up will be needed to process this file.
@c
@c  A suitable texinfo.tex is supplied, a newer one should work
@c  equally well.
@c
@c  The edition number is in the VERSION variable above and should be
@c  updated where appropriate.  Also, update the month and year in
@c  UPDATED-MONTH.


@dircategory GNU libraries
@direntry
* mpfr: (mpfr).                 Multiple Precision Floating-Point Reliable Library.
@end direntry

@c  html <meta name=description content="...">
@documentdescription
How to install and use MPFR, a library for reliable multiple precision floating-point arithmetic, version @value{VERSION}.
@end documentdescription

@c smallbook
@finalout
@setchapternewpage on

@ifnottex
@node Top, Copying, (dir), (dir)
@top MPFR
@end ifnottex

@iftex
@titlepage
@title MPFR
@subtitle The Multiple Precision Floating-Point Reliable Library
@subtitle Edition @value{VERSION}
@subtitle @value{UPDATED-MONTH}

@author The MPFR team, LORIA/INRIA Lorraine
@email{mpfr@@loria.fr}

@c Include the Distribution inside the titlepage so
@c that headings are turned off.

@tex
\global\parindent=0pt
\global\parskip=8pt
\global\baselineskip=13pt
@end tex

@page
@vskip 0pt plus 1filll
@end iftex

@insertcopying
@ifnottex
@sp 1
@end ifnottex

@iftex
@end titlepage
@headings double
@end iftex

@c  Don't bother with contents for html, the menus seem adequate.
@ifnothtml
@contents
@end ifnothtml

@menu
* Copying::                   GMP Copying Conditions (LGPL).
* Introduction to MPFR::      Brief introduction to MPFR.
* Installing MPFR::           How to configure and compile the MPFR library.
* MPFR Basics::               What every MPFR user should now.
* Reporting Bugs::            How to usefully report bugs.
* Floating-point Functions::  Functions for arithmetic on floats.

* Contributors::
* References::
* GNU Free Documentation License::  
* Concept Index::
* Function Index::
@end menu


@c  @m{T,N} is $T$ in tex or @math{N} otherwise.  This is an easy way to give
@c  different forms for math in tex and info.  Commas in N or T don't work,
@c  but @C{} can be used instead.  \, works in info but not in tex.
@iftex
@macro m {T,N}
@tex$\T\$@end tex
@end macro
@end iftex
@ifnottex
@macro m {T,N}
@math{\N\}
@end macro
@end ifnottex

@c  Usage: @GMPabs{x}
@c  Give either |x| in tex, or abs(x) in info or html.
@tex
\gdef\GMPabs#1{|#1|}
@end tex
@ifnottex
@macro GMPabs {X}
@abs{}(\X\)
@end macro
@end ifnottex

@c  Usage: @GMPtimes{}
@c  Give either \times or the word "times".
@tex
\gdef\GMPtimes{\times}
@end tex
@ifnottex
@macro GMPtimes
times
@end macro
@end ifnottex

@c  New math operators.
@c  @abs{} can be used in both tex and info, or just \abs in tex.
@tex
\gdef\abs{\mathop{\rm abs}}
@end tex
@ifnottex
@macro abs
abs
@end macro
@end ifnottex

@c  @times{} made available as a "*" in info and html (already works in tex).
@ifnottex
@macro times
*
@end macro
@end ifnottex

@c  Math operators already available in tex, made available in info too.
@c  For example @log{} can be used in both tex and info.
@ifnottex
@macro le
<=
@end macro
@macro log
log
@end macro
@end ifnottex


@node Copying, Introduction to MPFR, Top, Top
@comment  node-name, next, previous,  up
@unnumbered MPFR Copying Conditions
@cindex Copying conditions
@cindex Conditions for copying MPFR

This library is @dfn{free}; this means that everyone is free to use it and
free to redistribute it on a free basis.  The library is not in the public
domain; it is copyrighted and there are restrictions on its distribution, but
these restrictions are designed to permit everything that a good cooperating
citizen would want to do.  What is not allowed is to try to prevent others
from further sharing any version of this library that they might get from
you.@refill

Specifically, we want to make sure that you have the right to give away copies
of the library, that you receive source code or else can get it if you want
it, that you can change this library or use pieces of it in new free programs,
and that you know you can do these things.@refill

To make sure that everyone has such rights, we have to forbid you to deprive
anyone else of these rights.  For example, if you distribute copies of the
MPFR library, you must give the recipients all the rights that you have.  You
must make sure that they, too, receive or can get the source code.  And you
must tell them their rights.@refill

Also, for our own protection, we must make certain that everyone finds out
that there is no warranty for the MPFR library.  If it is modified by
someone else and passed on, we want their recipients to know that what they
have is not what we distributed, so that any problems introduced by others
will not reflect on our reputation.@refill

The precise conditions of the license for the MPFR library are found in the
Lesser General Public License that accompanies the source code.
See the file COPYING.LIB.@refill

@node Introduction to MPFR, Installing MPFR, Copying, Top
@comment  node-name,  next,  previous,  up
@chapter Introduction to MPFR


MPFR is a portable library written in C for arbitrary precision arithmetic
on reliable floating-point numbers. It is based on the GNU MP library.
It aims to extend the class of floating-point numbers provided by the
GNU MP library by @dfn{reliable} floating-point numbers. It may replace
the GNU MP floating-point numbers in a future release. The main differences
with the @code{mpf} class are: 

@itemize @bullet
@item the @code{mpfr} code is portable, i.e.@: the result of any operation
does not depend (or should not) on the machine word size 
@code{mp_bits_per_limb} (32 or 64 on most machines);
@item the precision in bits can be set exactly to any valid value
for each variable (including very small precision);
@item @code{mpfr} provides the four rounding modes from the IEEE 754-1985
standard.
@end itemize

In particular, with a precision of 53 bits, @code{mpfr} should be able
to exactly reproduce all computations with double-precision machine 
floating-point
numbers (@code{double} type in C), except the default exponent range
is much wider and subnormal numbers are not implemented.

This version of MPFR is released under the GNU Lesser General Public
License.
It is permitted to link MPFR to non-free programs, as long as when
distributing them the MPFR source code and a means to re-link with a
modified MPFR is provided.

@section How to use this Manual

Everyone should read @ref{MPFR Basics}.  If you need to install the library
yourself, you need to read @ref{Installing MPFR}, too.

The rest of the manual can be used for later reference, although it is
probably a good idea to glance through it.

@node Installing MPFR, Reporting Bugs, Introduction to MPFR, Top
@comment  node-name,  next,  previous,  up
@chapter Installing MPFR
@cindex Installation

Here are the steps needed to install the library on Unix systems
(more details are provided in the @file{INSTALL} file):

@enumerate
@item
To build MPFR, you first have to install GNU MP 
(version 4.1 or higher) on your computer.
You need a C compiler, preferably GCC, but any reasonable compiler should
work.  And you need a standard Unix @samp{make} program, plus some other
standard Unix utility programs.
MPFR needs some internal GMP header files that are not installed.
So, keep the GMP build directory as is, at least until you have
built MPFR.

@item
In the MPFR build directory, type
@samp{./configure --with-gmp-include=GMPBUILD --with-gmp-lib=GMPINSTALL/lib}
where @samp{GMPBUILD} is the GMP build directory and @samp{GMPINSTALL} the
directory where you have installed GMP. Because of the internal header files
required by MPFR, the option @samp{--with-gmp=GMPINSTALL} is not sufficient
and should not be used.
If you get error messages, you might check that you use the same compiler
and compile options as for GNU MP (see the @file{INSTALL} file).

@item
@samp{make}

This will compile MPFR, and create a library archive file @file{libmpfr.a} 
in the working directory.

@item
@samp{make check}

This will make sure MPFR was built correctly.  
If you get error messages, please
report this to @samp{mpfr@@loria.fr}.  (@xref{Reporting Bugs}, for
information on what to include in useful bug reports.)

@item
@samp{make install}

This will copy the files @file{mpfr.h} and @file{mpf2mpfr.h},
and @file{libmpfr.a}, 
to the directories @file{/usr/local/include} and @file{/usr/local/lib}
respectively (or if you passed the @samp{--prefix} option to
@file{configure}, to the directory given as argument to @samp{--prefix}).
This will also install @file{mpfr.info} in @file{/usr/local/info}.
@end enumerate

There are some other useful make targets:

@itemize @bullet
@item
@samp{mpfr.dvi} or @samp{dvi}

Create a DVI version of the manual, in @file{mpfr.dvi}.
@c and a set of info files, in @file{mpfr.info}, @file{mpfr.info-1}, @file{mpfr.info-2}, etc.

@item
@samp{mpfr.ps}

Create a Postscript version of the manual, in @file{mpfr.ps}.

@c @item
@c @samp{html}
@c Create a HTML version of the manual, in @file{mpfr.html}.

@item
@samp{clean}

Delete all object files and archive files, but not the configuration files.

@item
@samp{distclean}

Delete all files not included in the distribution.

@item
@samp{uninstall}
Delete all files copied by @samp{make install}.
@end itemize


@section Known Build Problems

MPFR suffers from all bugs from the GNU MP library, plus many many more.

Please report other problems to @samp{mpfr@@loria.fr}.
@xref{Reporting Bugs}.
Some bug fixes are available on the MPFR web page
@samp{http://www.loria.fr/projets/mpfr/} or @samp{http://www.mpfr.org/}.


@node Reporting Bugs, MPFR Basics, Installing MPFR, Top
@comment  node-name,  next,  previous,  up
@chapter Reporting Bugs
@cindex Reporting bugs

If you think you have found a bug in the MPFR library, first have a look on the
MPFR web page @samp{http://www.loria.fr/projets/mpfr/} or
@samp{http://www.mpfr.org/}: perhaps this bug is already known,
in which case you will find a workaround for it.
Otherwise, please investigate
and report it. We have made this library available to you, and it is not to ask
too much from you, to ask you to report the bugs that you find.

There are a few things you should think about when you put your bug report
together.

You have to send us a test case that makes it possible for us to reproduce the
bug.  Include instructions on how to run the test case.

You also have to explain what is wrong; if you get a crash, or if the results
printed are incorrect and in that case, in what way.

Please include compiler version information
in your bug report.  This can be extracted using @samp{cc -V} on some
machines, or,
if you're using gcc, @samp{gcc -v}.  Also, include the output from @samp{uname
-a}.

If your bug report is good, we will do our best to help you to get a corrected
version of the library; if the bug report is poor, we won't do anything about
it (aside of chiding you to send better bug reports).

Send your bug report to: @samp{mpfr@@loria.fr}.

If you think something in this manual is unclear, or downright incorrect, or if
the language needs to be improved, please send a note to the same address.

@node MPFR Basics, Floating-point Functions, Reporting Bugs, Top
@comment  node-name,  next,  previous,  up
@chapter MPFR Basics


@cindex @file{mpfr.h}
All declarations needed to use MPFR are collected in the include file
@file{mpfr.h}.  It is designed to work with both C and C++ compilers.
You should include that file in any program using the MPFR library:

@code{#include "mpfr.h"}

@section Nomenclature and Types

@cindex Floating-point number
@tindex @code{mpfr_t}
@noindent
@dfn{Floating-point number} or @dfn{Float} for short, is an arbitrary precision
mantissa with a limited precision exponent.  The C data type for such objects
is @code{mpfr_t}.
A floating-point number can have three special values: Not-a-Number (NaN)
or plus or minus Infinity. NaN represents a value which cannot be represented
in the floating-point format, like 0 divided by 0, or Infinity minus Infinity.
Moreover, like in the IEEE 754-1985 standard, zero is signed, i.e.@: there are
a +0 and a -0; the behavior is the same as in the IEEE 754-1985 standard and
it is generalized to the other functions supported by MPFR.


@cindex Precision
@tindex @code{mp_prec_t}
@noindent
The @dfn{Precision} is the number of bits used to represent the mantissa
of a floating-point number;
the corresponding C data type is @code{mp_prec_t}.
The precision can be any integer between @code{MPFR_PREC_MIN} and
@code{MPFR_PREC_MAX}. In the current implementation, @code{MPFR_PREC_MIN}
is equal to 2 and @code{MPFR_PREC_MAX} is equal to @code{ULONG_MAX}.

@cindex Rounding Mode
@tindex @code{mp_rnd_t}
@noindent
The @dfn{rounding mode} specifies the way to round the result of a 
floating-point operation, in case the exact result can not be represented
exactly in the destination mantissa;
the corresponding C data type is @code{mp_rnd_t}.

@cindex Limb
@c @tindex @code{mp_limb_t}
@noindent
A @dfn{limb} means the part of a multi-precision number that fits in a single
word.  (We chose this word because a limb of the human body is analogous to a
digit, only larger, and containing several digits.)  Normally a limb contains
32 or 64 bits.  The C data type for a limb is @code{mp_limb_t}.

@section Function Classes

There is only one class of functions in the MPFR library:

@enumerate
@item
Functions for floating-point arithmetic, with names beginning with
@code{mpfr_}.  The associated type is @code{mpfr_t}.
@end enumerate


@section MPFR Variable Conventions

As a general rule, all MPFR functions expect output arguments before input
arguments.  This notation is based on an analogy with the assignment operator.

MPFR allows you to use the same variable for both input and output in the same
expression.  For example, the main function for floating-point multiplication,
@code{mpfr_mul}, can be used like this: @code{mpfr_mul (x, x, x, rnd_mode)}.  
This
computes the square of @var{x} with rounding mode @code{rnd_mode}
and puts the result back in @var{x}.

Before you can assign to an MPFR variable, you need to initialize it by calling
one of the special initialization functions.  When you're done with a
variable, you need to clear it out, using one of the functions for that
purpose.  

A variable should only be initialized once, or at least cleared out between
each initialization.  After a variable has been initialized, it may be
assigned to any number of times.

For efficiency reasons, avoid to initialize and clear out a variable in loops.
Instead, initialize it before entering the loop, and clear it out after the
loop has exited.

You don't need to be concerned about allocating additional space for MPFR
variables, since any variable has a mantissa of fixed size.
Hence unless you change its precision, or clear and reinitialize it, 
a floating-point variable will have the same allocated space during all its
life.

@section Compatibility with MPF

A header file @file{mpf2mpfr.h} is included in the distribution of MPFR for
compatibility with the GNU MP class MPF.
After inserting the following two lines after the @code{#include "gmp.h"}
line,

@code{#include "mpfr.h"}

@code{#include "mpf2mpfr.h"}

any program written for
MPF can be linked directly with MPFR without any changes.
All operations are then performed with the default MPFR rounding mode,
which can be reset with @code{mpfr_set_default_rounding_mode}.

@deftypevr {Global Variable} {mp_rnd_t} __gmp_default_rounding_mode
The default rounding mode (to nearest initially).
@end deftypevr

@section Getting the Latest Version of MPFR

The latest version of MPFR is available from
@samp{http://www.loria.fr/projets/mpfr/} or @samp{http://www.mpfr.org/}.

@node Floating-point Functions, Contributors, MPFR Basics, Top
@comment  node-name,  next,  previous,  up
@chapter Floating-point Functions
@cindex Floating-point functions
@cindex Float functions

The floating-point functions expect arguments of type @code{mpfr_t}.

The MPFR floating-point functions have an interface that is similar to the 
GNU MP
integer functions.  The function prefix for floating-point operations is
@code{mpfr_}.

There is one significant characteristic of floating-point numbers that has
motivated a difference between this function class and other GNU MP function
classes: the inherent inexactness of floating-point arithmetic.  The user has
to specify the precision for each variable.  A computation that assigns a
variable will take place with the precision of the assigned variable; the
cost of that computation should not depend from the 
precision of variables used as input (on average).

@cindex Precision
The semantics of a calculation in MPFR is specified as follows: Compute the
requested operation exactly (with ``infinite accuracy''), and round the result
to the precision of the destination variable, with the given rounding mode.
The MPFR floating-point functions are intended to be a smooth extension
of the IEEE 754-1985 arithmetic. The results obtained on one computer should
not differ from the results obtained on a computer with a different word size.

@cindex Accuracy
MPFR does not keep track of the accuracy of a computation. This is left
to the user or to a higher layer.
As a consequence, if two variables are used to store
only a few significant bits, and their product is stored in a variable with large
precision, then MPFR will still compute the result with full precision.

@menu
* Rounding Modes::              
* Exceptions::                  
* Initializing Floats::         
* Assigning Floats::            
* Simultaneous Float Init & Assign::  
* Converting Floats::           
* Float Arithmetic::            
* Float Comparison::            
* Special Functions::           
* I/O of Floats::               
* Miscellaneous Float Functions::  
* Internals::                   
@end menu

@node Rounding Modes, Exceptions, Floating-point Functions, Floating-point Functions
@cindex Rounding modes
@section Rounding Modes

The following four rounding modes are supported:
@itemize @bullet
@item @code{GMP_RNDN}: round to nearest
@item @code{GMP_RNDZ}: round towards zero
@item @code{GMP_RNDU}: round towards plus infinity
@item @code{GMP_RNDD}: round towards minus infinity
@end itemize
The @samp{round to nearest} mode works as in the IEEE 754-1985 standard: in
case the number to be rounded lies exactly in the middle of two representable
numbers, it is rounded to the one with the least significant bit set to zero.
For example, the number 5, which is represented by (101) in binary, is rounded
to (100)=4 with a precision of two bits, and not to (110)=6.
This rule avoids the @dfn{drift} phenomenon mentioned by Knuth in volume 2
of The Art of Computer Programming (section 4.2.2, pages 221-222).

Most MPFR functions take as first argument the destination variable,
as second and following arguments the input variables,
as last argument a rounding mode, and 
have a return value of type @code{int}. If this value is zero, it means
that the value stored in the destination variable is the exact result of
the corresponding mathematical function. If the returned value is positive
(resp.@: negative), it means the value stored in the destination variable
is greater (resp.@: lower) than the exact result.
For example with the @code{GMP_RNDU} rounding mode, the returned value
is usually positive, except when the result is exact, in which case it is
zero.
In the case of an infinite result, it is considered as inexact when it was
obtained by overflow, and exact otherwise.
A NaN result (Not-a-Number) always corresponds to an inexact return value.

@deftypefun void mpfr_set_default_rounding_mode (mp_rnd_t @var{rnd})
Sets the default rounding mode to @var{rnd}.
The default rounding mode is to nearest initially.
@end deftypefun

@deftypefun int mpfr_round_prec (mpfr_t @var{x}, mp_rnd_t @var{rnd}, mp_prec_t @var{prec})
Rounds @var{x} according to @var{rnd} with precision @var{prec}, which
may be different from that of @var{x}. 
If @var{prec} is greater or equal to the precision of @var{x}, then new
space is allocated for the mantissa, and it is filled with zeros.
Otherwise, the mantissa is rounded to precision @var{prec} with the given
direction. In both cases, the precision of @var{x} is changed to @var{prec}.
The returned value is zero when the result is exact, positive when it is
greater than the original value of @var{x}, and negative when it is smaller.
The precision @var{prec} can be any integer between @code{MPFR_PREC_MIN} and
@code{MPFR_PREC_MAX}.
@end deftypefun

@deftypefun {char *} mpfr_print_rnd_mode (mp_rnd_t @var{rnd})
Returns the input string (GMP_RNDD, GMP_RNDU, GMP_RNDN, GMP_RNDZ)
corresponding to the rounding mode @var{rnd} or a null pointer if
@var{rnd} is an invalid rounding mode.
@end deftypefun

@node Exceptions, Initializing Floats, Rounding Modes, Floating-point Functions
@comment  node-name,  next,  previous,  up
@section Exceptions

Note: Overflow handling is still experimental and currently implemented
very partially. If an overflow occurs internally at the wrong place,
anything can happen (crash, wrong results, etc).

@deftypefun mp_exp_t mpfr_get_emin (void)
@deftypefunx mp_exp_t mpfr_get_emax (void)
Return the (current) smallest and largest exponents allowed for a 
floating-point variable.
@end deftypefun

@deftypefun int mpfr_set_emin (mp_exp_t @var{exp})
@deftypefunx int mpfr_set_emax (mp_exp_t @var{exp})
Set the smallest and largest exponents allowed for a floating-point variable.
Return a non-zero value when @var{exp} is not in the range accepted by the
implementation (in that case the smallest or largest exponent is not changed),
and zero otherwise.
If the user changes the exponent range, it is her/his responsibility to check
that all current floating-point variables are in the new allowed range
(for example using @code{mpfr_check_range}),
otherwise the subsequent
behaviour will be undefined, in the sense of the ISO C standard.
@end deftypefun

@deftypefun int mpfr_check_range (mpfr_t @var{x}, int @var{t}, mp_rnd_t @var{rnd})
This function forces @var{x} to be in the current range of acceptable
values, @var{t} being the current ternary value: negative if @var{x}
is smaller than the exact value, positive if @var{x} is larger than
the exact value and zero if @var{x} is exact (before the call). It
generates an underflow or an overflow if the exponent of @var{x} is
outside the current allowed range; the value of @var{t} may be used
to avoid a double rounding. This function returns zero if the rounded
result is equal to the exact one, a positive value if the rounded
result is larger than the exact one, a negative value if the rounded
result is smaller than the exact one. Note that unlike most functions,
the results is compared to the exact one, not the original value of
@var{x}, i.e.@: the ternary value is propagated.
@end deftypefun

@deftypefun void mpfr_clear_underflow (void)
@deftypefunx void mpfr_clear_overflow (void)
@deftypefunx void mpfr_clear_nanflag (void)
@deftypefunx void mpfr_clear_inexflag (void)
Clear the underflow, overflow, invalid, and inexact flags.
@end deftypefun

@deftypefun void mpfr_clear_flags (void)
Clear all global flags (underflow, overflow, inexact, invalid).
@end deftypefun

@deftypefun int mpfr_underflow_p (void)
@deftypefunx int mpfr_overflow_p (void)
@deftypefunx int mpfr_nanflag_p (void)
@deftypefunx int mpfr_inexflag_p (void)
Return the corresponding (underflow, overflow, invalid, inexact) flag,
which is non-zero iff the flag is set.
@end deftypefun

@node Initializing Floats, Assigning Floats, Exceptions, Floating-point Functions
@comment  node-name,  next,  previous,  up
@section Initialization and Assignment Functions

@deftypefun void mpfr_set_default_prec (mp_prec_t @var{prec})
Set the default precision to be @strong{exactly} @var{prec} bits.  The
precision of a variable means the number of bits used to store its mantissa.
All
subsequent calls to @code{mpfr_init} will use this precision, but previously
initialized variables are unaffected.
This default precision is set to 53 bits initially.
The precision can be any integer between @code{MPFR_PREC_MIN} and
@code{MPFR_PREC_MAX}.
@end deftypefun

@deftypefun mp_prec_t mpfr_get_default_prec ()
Returns the default MPFR precision in bits.
@end deftypefun

An @code{mpfr_t} object must be initialized before storing the first value in
it.  The functions @code{mpfr_init} and @code{mpfr_init2} are used for that
purpose.

@deftypefun void mpfr_init (mpfr_t @var{x})
Initialize @var{x} and set its value to NaN.

Normally, a variable should be initialized once only
or at least be cleared, using @code{mpfr_clear}, between initializations.  The
precision of @var{x} is the default precision, which can be changed
by a call to @code{mpfr_set_default_prec}.
@end deftypefun

@deftypefun void mpfr_init2 (mpfr_t @var{x}, mp_prec_t @var{prec})
Initialize @var{x}, set its precision to be @strong{exactly}
@var{prec} bits and its value to NaN.

Normally, a variable should be initialized once only or at
least be cleared, using @code{mpfr_clear}, between initializations.
To change the precision of a variable which has already been initialized,
use @code{mpfr_set_prec} instead.
The precision @var{prec} can be any integer between @code{MPFR_PREC_MIN} and
@code{MPFR_PREC_MAX}.
@end deftypefun

@deftypefun void mpfr_clear (mpfr_t @var{x})
Free the space occupied by @var{x}.  Make sure to call this function for all
@code{mpfr_t} variables when you are done with them.
@end deftypefun

@need 2000
Here is an example on how to initialize floating-point variables:

@example
@{
  mpfr_t x, y;
  mpfr_init (x);			/* use default precision */
  mpfr_init2 (y, 256);		/* precision @emph{exactly} 256 bits */
  @dots{}
  /* Unless the program is about to exit, do ... */
  mpfr_clear (x);
  mpfr_clear (y);
@}
@end example

The following two functions are useful for changing the precision during a
calculation.  A typical use would be for adjusting the precision gradually in
iterative algorithms like Newton-Raphson, making the computation precision
closely match the actual accurate part of the numbers.

@deftypefun void mpfr_set_prec (mpfr_t @var{x}, mp_prec_t @var{prec})
Reset the precision of @var{x} to be @strong{exactly} @var{prec} bits,
and set its value to NaN.
The previous value stored in @var{x} is lost. It is equivalent to
a call to @code{mpfr_clear(x)} followed by a call to 
@code{mpfr_init2(x, prec)}, but more efficient as no allocation is done in
case the current allocated space for the mantissa of @var{x} is enough.
The precision @var{prec} can be any integer between @code{MPFR_PREC_MIN} and
@code{MPFR_PREC_MAX}.

In case you want to keep the previous value stored in @var{x},
use @code{mpfr_round_prec} instead.
@end deftypefun

@deftypefun mp_prec_t mpfr_get_prec (mpfr_t @var{x})
Return the precision actually used for assignments of @var{x}, i.e.
the number of bits used to store its mantissa.
@end deftypefun

@deftypefun void mpfr_set_prec_raw (mpfr_t @var{x}, unsigned long int @var{p})
Reset the precision of @var{x} to be @strong{exactly} @var{prec} bits.
The only difference with @code{mpfr_set_prec} is that @var{p} is assumed to
be small enough so that the mantissa fits into the current allocated memory
space for @var{x}. Otherwise an error will occur.
@end deftypefun

@node Assigning Floats, Simultaneous Float Init & Assign, Initializing Floats, Floating-point Functions
@comment  node-name,  next,  previous,  up
@section Assignment Functions
@cindex Float assignment functions

These functions assign new values to already initialized floats
(@pxref{Initializing Floats}).

@deftypefun int mpfr_set (mpfr_t @var{rop}, mpfr_t @var{op}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_set_ui (mpfr_t @var{rop}, unsigned long int @var{op}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_set_si (mpfr_t @var{rop}, long int @var{op}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_set_d (mpfr_t @var{rop}, double @var{op}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_set_ld (mpfr_t @var{rop}, long double @var{op}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_set_z (mpfr_t @var{rop}, mpz_t @var{op}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_set_q (mpfr_t @var{rop}, mpq_t @var{op}, mp_rnd_t @var{rnd})
Set the value of @var{rop} from @var{op}, rounded to the precision of @var{rop}
towards the given direction @var{rnd}.
Please note that even a @code{long int} may have to be rounded,
if the destination precision is less than the machine word width.
The return value is zero when @var{rop}=@var{op}, positive when 
@var{rop}>@var{op},
and negative when @var{rop}<@var{op}.
For @code{mpfr_set_d}, be careful that the input number @var{op}
may not be exactly representable as a double-precision number (this happens for
0.1 for instance), in which case it is first
rounded by the C compiler to a double-precision number, and then only
to a @code{mpfr} floating-point number.

Please note that the ISO/IEC 9899:1999 (ISO C99)
standard does not specify exactly the mantissa
width of the long double type; the @code{mpfr_set_ld} function assumes
it has at most 113 bits, and an exponent of at most 15 bits.
@end deftypefun

@deftypefun int mpfr_set_str (mpfr_t @var{x}, const char *@var{s}, int @var{base}, mp_rnd_t @var{rnd})
Set @var{x} to the value of the string @var{s} in base @var{base} (between
2 and 36), rounded in direction @var{rnd} to the precision of @var{x}.
See the documentation of @code{mpfr_inp_str} for a detailed description 
of the valid string formats.
This function returns 0 if the entire string up to the final '\0' is a
valid number in base @var{base}; otherwise it returns @minus{}1.

Special values can be read as follows: @code{NaN}, @code{Inf}, @code{+Inf}
and @code{-Inf} (possibly in lower case when the base is less than 24).
@end deftypefun

@deftypefun void mpfr_set_str_raw (mpfr_t @var{x}, const char *@var{s})
Set @var{x} to the value of the binary number in string @var{s}, which has to 
be of the
form +/-xxxx.xxxxxxEyy. The exponent is read in decimal, but is interpreted
as the power of two to be multiplied by the mantissa.
The mantissa length of @var{s} has to be less or equal to the precision of
@var{x}, otherwise an error occurs.
If @var{s} starts with @code{N}, it is interpreted as NaN (Not-a-Number);
if it starts with @code{I} after the sign, it is interpreted as infinity,
with the corresponding sign.
@end deftypefun

@deftypefun int mpfr_set_f (mpfr_t @var{x}, mpf_t @var{y}, mp_rnd_t @var{rnd})
Set @var{x} to the GNU MP floating-point number
@var{y}, rounded with the @var{rnd} mode and the precision
of @var{x}.
The returned value is zero when @var{x}=@var{y}, positive when @var{x}>@var{y},
and negative when @var{x}<@var{y}.
@end deftypefun

@deftypefun void mpfr_set_inf (mpfr_t @var{x}, int @var{sign})
@deftypefunx void mpfr_set_nan (mpfr_t @var{x})
Set the variable @var{x} to infinity or NaN (Not-a-Number) respectively.
In @code{mpfr_set_inf}, @var{x} is set to plus infinity iff @var{sign} is
positive.
@end deftypefun

@deftypefun void mpfr_swap (mpfr_t @var{x}, mpfr_t @var{y})
Swap the values @var{x} and @var{y} efficiently. Warning: the
precisions are exchanged too; in case the precisions are different,
@code{mpfr_swap} is thus not equivalent to three @code{mpfr_set} calls
using a third auxiliary variable.
@end deftypefun

@node Simultaneous Float Init & Assign, Converting Floats, Assigning Floats, Floating-point Functions
@comment  node-name,  next,  previous,  up
@section Combined Initialization and Assignment Functions
@cindex Initialization and assignment functions

@deftypefn Macro int mpfr_init_set (mpfr_t @var{rop}, mpfr_t @var{op}, mp_rnd_t @var{rnd})
@deftypefnx Macro int mpfr_init_set_ui (mpfr_t @var{rop}, unsigned long int @var{op}, mp_rnd_t @var{rnd})
@deftypefnx Macro int mpfr_init_set_si (mpfr_t @var{rop}, signed long int @var{op}, mp_rnd_t @var{rnd})
@deftypefnx Macro int mpfr_init_set_d (mpfr_t @var{rop}, double @var{op}, mp_rnd_t @var{rnd})
@deftypefnx Macro int mpfr_init_set_f (mpfr_t @var{rop}, mpf_t @var{op}, mp_rnd_t @var{rnd})
@deftypefnx Macro int mpfr_init_set_z (mpfr_t @var{rop}, mpz_t @var{op}, mp_rnd_t @var{rnd})
@deftypefnx Macro int mpfr_init_set_q (mpfr_t @var{rop}, mpq_t @var{op}, mp_rnd_t @var{rnd})
Initialize @var{rop} and set its value from @var{op}, rounded to direction
@var{rnd}.
The precision of @var{rop} will be taken from the active default precision,
as set by @code{mpfr_set_default_prec}.
The return value if zero if @var{rop}=@var{op}, positive if @var{rop}>@var{op},
and negative when @var{rop}<@var{op}.
@end deftypefn

@deftypefun int mpfr_init_set_str (mpfr_t @var{x}, const char *@var{s}, int @var{base}, mp_rnd_t @var{rnd})
Initialize @var{x} and set its value from
the string @var{s} in base @var{base}, 
rounded to direction @var{rnd}.
See @code{mpfr_set_str}.
@end deftypefun

@node Converting Floats, Float Arithmetic, Simultaneous Float Init & Assign, Floating-point Functions
@comment  node-name,  next,  previous,  up
@section Conversion Functions
@cindex Conversion functions

@deftypefun double mpfr_get_d (mpfr_t @var{op}, mp_rnd_t @var{rnd})
@deftypefunx {long double} mpfr_get_ld (mpfr_t @var{op}, mp_rnd_t @var{rnd})
Convert @var{op} to a double (respectively long double),
using the rounding mode @var{rnd}.
Please note that the ISO/IEC 9899:1999 (ISO C99)
standard does not specify exactly the mantissa
width of the long double type; the @code{mpfr_get_ld} function assumes
it has at most 113 bits, and an exponent of at most 15 bits.
@end deftypefun

@deftypefun double mpfr_get_d1 (mpfr_t @var{op})
Convert @var{op} to a double, using the default MPFR rounding mode
(see function @code{mpfr_set_default_rounding_mode}).
@end deftypefun

@deftypefun double mpfr_get_d_2exp (mp_exp_t *@var{exp}, mpfr_t @var{op}, mp_rnd_t @var{rnd})
Find @var{d} and @var{exp} such that @m{@var{d}\times 2^{exp}, @var{d} times 2
raised to @var{exp}}, with @math{0.5@le{}@GMPabs{@var{d}}<1} equals
@var{op} rounded to double precision, using the default MPFR rounding mode.
Note that @var{exp} may exceed the IEEE 754 exponent range.
@end deftypefun

@deftypefun long mpfr_get_si (mpfr_t @var{op}, mp_rnd_t @var{rnd})
@deftypefunx {unsigned long} mpfr_get_ui (mpfr_t @var{op}, mp_rnd_t @var{op})
Convert @var{op} to a @code{long} or @code{unsigned long}, after rounding
it with respect to @var{rnd}.
If @var{op} is too big for the return type, NaN or Inf,
the result is undefined.

See also @code{mpfr_fits_slong_p} and @code{mpfr_fits_ulong_p}
(@pxref{Miscellaneous Float Functions}).
@end deftypefun

@deftypefun mp_exp_t mpfr_get_z_exp (mpz_t @var{z}, mpfr_t @var{op})
Puts the mantissa of @var{op} into @var{z}, and returns the exponent
@var{exp} (which may be outside the current exponent range) such that
@var{op} equals
@ifnottex
@var{z} multiplied by two exponent @var{exp}.
@end ifnottex
@tex
$z \times 2^{\rm exp}$.
@end tex
@end deftypefun

@deftypefun {char *} mpfr_get_str (char *@var{str}, mp_exp_t *@var{expptr}, int @var{base}, size_t @var{n_digits}, mpfr_t @var{op}, mp_rnd_t @var{rnd})
Convert @var{op} to a string of digits in base @var{base}, with rounding in
direction @var{rnd}. The base may vary
from 2 to 36.  Generate exactly @var{n_digits} significant digits
which must be at least 2.

If @var{n_digits} is zero, the number of digits of the mantissa is determined
automatically from the precision of @var{op} and the value of @var{base}.
Warning: this functionality may disappear or change in future versions.

If @var{str} is a null pointer, space for the mantissa is allocated using
the current allocation function (@pxref{Custom Allocation,,, gmp, GNU
MP}), and a pointer to the string is returned.  The block will be
@code{strlen(s)+1} bytes.

If @var{str} is not a null pointer, it should point to a block of storage
large enough for the mantissa, i.e., @var{n_digits} + 2 or more. The extra
two bytes are for a possible minus sign, and for the terminating null
character.

If the input number is a real number, the exponent is written through
the pointer @var{expptr} (the current minimal exponent for 0).

If @var{n_digits} is 0, note that the space requirements for @var{str}
in this case will be impossible for the user to predetermine. Therefore,
one needs to pass a null pointer for the string argument whenever
@var{n_digits} is 0.

The generated string is a fraction, with an implicit radix point immediately
to the left of the first digit.  For example, the number 3.1416 would be
returned as "31416" in the string and 1 written at @var{expptr}.

A pointer to the string is returned, unless there is an error, in which
case a null pointer is returned.
@end deftypefun


@node Float Arithmetic, Float Comparison, Converting Floats, Floating-point Functions
@comment  node-name,  next,  previous,  up
@section Basic Arithmetic Functions
@cindex Float arithmetic functions
@cindex Arithmetic functions

@deftypefun int mpfr_add (mpfr_t @var{rop}, mpfr_t @var{op1}, mpfr_t @var{op2}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_add_ui (mpfr_t @var{rop}, mpfr_t @var{op1}, unsigned long int @var{op2}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_add_z (mpfr_t @var{rop}, mpfr_t @var{op1}, mpz_t @var{op2}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_add_q (mpfr_t @var{rop}, mpfr_t @var{op1}, mpq_t @var{op2}, mp_rnd_t @var{rnd})
Set @var{rop} to @math{@var{op1} + @var{op2}} rounded in the direction @var{rnd}.
The return value is zero if @var{rop} is exactly @math{@var{op1} + @var{op2}},
positive if @var{rop} is larger than @math{@var{op1} + @var{op2}},
and negative if @var{rop} is smaller than @math{@var{op1} + @var{op2}}.
@end deftypefun

@deftypefun int mpfr_sub (mpfr_t @var{rop}, mpfr_t @var{op1}, mpfr_t @var{op2}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_ui_sub (mpfr_t @var{rop}, unsigned long int @var{op1}, mpfr_t @var{op2}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_sub_ui (mpfr_t @var{rop}, mpfr_t @var{op1}, unsigned long int @var{op2}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_sub_z (mpfr_t @var{rop}, mpfr_t @var{op1}, mpz_t @var{op2}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_sub_q (mpfr_t @var{rop}, mpfr_t @var{op1}, mpq_t @var{op2}, mp_rnd_t @var{rnd})
Set @var{rop} to @math{@var{op1} - @var{op2}} rounded in the direction @var{rnd}.
The return value is zero if @var{rop} is exactly @math{@var{op1} - @var{op2}},
positive if @var{rop} is larger than @math{@var{op1} - @var{op2}},
and negative if @var{rop} is smaller than @math{@var{op1} - @var{op2}}.
@end deftypefun

@deftypefun int mpfr_mul (mpfr_t @var{rop}, mpfr_t @var{op1}, mpfr_t @var{op2}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_mul_ui (mpfr_t @var{rop}, mpfr_t @var{op1}, unsigned long int @var{op2}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_mul_z (mpfr_t @var{rop}, mpfr_t @var{op1}, mpz_t @var{op2}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_mul_q (mpfr_t @var{rop}, mpfr_t @var{op1}, mpq_t @var{op2}, mp_rnd_t @var{rnd})
Set @var{rop} to @math{@var{op1} @GMPtimes{} @var{op2}} rounded in the
direction @var{rnd}.  Return 0 if the result is exact, a positive
value if @math{@var{rop} > @var{op1}@times{}@var{op2}}, a
negative value otherwise.
@end deftypefun

@deftypefun int mpfr_div (mpfr_t @var{rop}, mpfr_t @var{op1}, mpfr_t @var{op2}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_ui_div (mpfr_t @var{rop}, unsigned long int @var{op1}, mpfr_t @var{op2}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_div_ui (mpfr_t @var{rop}, mpfr_t @var{op1}, unsigned long int @var{op2}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_div_z (mpfr_t @var{rop}, mpfr_t @var{op1}, mpz_t @var{op2}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_div_q (mpfr_t @var{rop}, mpfr_t @var{op1}, mpq_t @var{op2}, mp_rnd_t @var{rnd})
Set @var{rop} to @math{@var{op1}/@var{op2}} rounded in the direction @var{rnd}.
These functions return 0 if the division is exact, 
a positive value when @var{rop} is larger than @math{@var{op1}/@var{op2}},
and a negative value otherwise.
@end deftypefun

@deftypefun int mpfr_sqrt (mpfr_t @var{rop}, mpfr_t @var{op}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_sqrt_ui (mpfr_t @var{rop}, unsigned long int @var{op}, mp_rnd_t @var{rnd})
Set @var{rop} to @m{\sqrt{@var{op}}, the square root of @var{op}}
rounded in the direction @var{rnd}.
Set @var{rop} to NaN if @var{op} is negative.
Return 0 if the operation is exact, a non-zero value otherwise.
@end deftypefun

@deftypefun int mpfr_cbrt (mpfr_t @var{rop}, mpfr_t @var{op}, mp_rnd_t @var{rnd})
Set @var{rop} to @m{{@var{op}^{1/3}}, the cubic root of @var{op}}
rounded in the direction @var{rnd}.
Return 0 if the operation is exact, a positive value when the return value
is larger than @m{{@var{op}^{1/3}}, the cubic root of @var{op}},
a negative value otherwise.
@end deftypefun

@deftypefun int mpfr_pow_ui (mpfr_t @var{rop}, mpfr_t @var{op1}, unsigned long int @var{op2}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_ui_pow_ui (mpfr_t @var{rop}, unsigned long int @var{op1}, unsigned long int @var{op2}, mp_rnd_t @var{rnd})
Set @var{rop} to @m{@var{op1}^{op2}, @var{op1} raised to @var{op2}}. The
computation is done by binary exponentiation.
Return 0 if the result is exact, a non-zero value otherwise (but the sign
of the return value has no meaning).
@end deftypefun

@deftypefun int mpfr_ui_pow (mpfr_t @var{rop}, unsigned long int @var{op1}, mpfr_t @var{op2}, mp_rnd_t @var{rnd})
Set @var{rop} to @m{@var{op1}^{op2}, @var{op1} raised to @var{op2}},
rounded to the direction @var{rnd} with the precision of @var{rop}.
Return zero iff the result is exact, a positive value when the
result is greater than @m{@var{op1}^{op2}, @var{op1} to the power @var{op2}},
and a negative value when it is smaller.
@end deftypefun

@deftypefun int mpfr_pow_si (mpfr_t @var{rop}, mpfr_t @var{op1}, long int @var{op2}, mp_rnd_t @var{rnd})
Set @var{rop} to @m{@var{op1}^{op2}, @var{op1} raised to the power @var{op2}},
rounded to the direction @var{rnd} with the
precision of @var{rop}. 
Return zero iff the result is exact.
@end deftypefun

@deftypefun int mpfr_pow (mpfr_t @var{rop}, mpfr_t @var{op1}, mpfr_t @var{op2}, mp_rnd_t @var{rnd})
Set @var{rop} to @m{@var{op1}^{op2}, @var{op1} raised to the power @var{op2}},
rounded to the direction @var{rnd} with the precision of @var{rop}.
If @var{op1} is negative then @var{rop} is set to NaN,
even if @var{op2} is an integer.
Return zero iff the result is exact.
@end deftypefun

@deftypefun int mpfr_neg (mpfr_t @var{rop}, mpfr_t @var{op}, mp_rnd_t @var{rnd})
Set @var{rop} to @math{-@var{op}} rounded in the direction @var{rnd}.
Just changes the sign
if @var{rop} and @var{op} are the same variable.
@end deftypefun

@deftypefun int mpfr_abs (mpfr_t @var{rop}, mpfr_t @var{op}, mp_rnd_t @var{rnd})
Set @var{rop} to the absolute value of @var{op},
rounded in the direction @var{rnd}.
Return 0 if the result is exact, a positive value if @var{rop} is larger than
the absolute value of @var{op}, and a negative value otherwise.
@end deftypefun

@deftypefun int mpfr_mul_2exp (mpfr_t @var{rop}, mpfr_t @var{op1}, unsigned long int @var{op2}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_mul_2ui (mpfr_t @var{rop}, mpfr_t @var{op1}, unsigned long int @var{op2}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_mul_2si (mpfr_t @var{rop}, mpfr_t @var{op1}, long int @var{op2}, mp_rnd_t @var{rnd})
Set @var{rop} to @m{@var{op1} \times 2^{op2}, @var{op1} times 2 raised
to @var{op2}}
rounded to the direction @var{rnd}. Just increases the exponent by @var{op2}
when @var{rop} and @var{op1} are identical.
Return zero when @math{@var{rop}=@var{op1}}, a positive value when @math{@var{rop}>@var{op1}},
and a negative value when @math{@var{rop}<@var{op1}}.
Note: The @code{mpfr_mul_2exp} function is defined for compatibility reasons;
you should use @code{mpfr_mul_2ui} (or @code{mpfr_mul_2si}) instead.
@end deftypefun

@deftypefun int mpfr_div_2exp (mpfr_t @var{rop}, mpfr_t @var{op1}, unsigned long int @var{op2}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_div_2ui (mpfr_t @var{rop}, mpfr_t @var{op1}, unsigned long int @var{op2}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_div_2si (mpfr_t @var{rop}, mpfr_t @var{op1}, long int @var{op2}, mp_rnd_t @var{rnd})
Set @var{rop} to @m{@var{op1}/2^{op2}, @var{op1} divided by 2 raised
to @var{op2}}
rounded to the direction @var{rnd}. Just decreases the exponent by @var{op2}
when @var{rop} and @var{op1} are identical.
Return zero when @math{@var{rop}=@var{op1}}, a positive value when @math{@var{rop}>@var{op1}},
and a negative value when @math{@var{rop}<@var{op1}}.
Note: The @code{mpfr_div_2exp} function is defined for compatibility reasons;
you should use @code{mpfr_div_2ui} (or @code{mpfr_div_2si}) instead.
@end deftypefun

@node Float Comparison, Special Functions, Float Arithmetic, Floating-point Functions
@comment  node-name,  next,  previous,  up
@section Comparison Functions
@cindex Float comparisons functions
@cindex Comparison functions

@deftypefun int mpfr_cmp (mpfr_t @var{op1}, mpfr_t @var{op2})
@deftypefunx int mpfr_cmp_ui (mpfr_t @var{op1}, unsigned long int @var{op2})
@deftypefunx int mpfr_cmp_si (mpfr_t @var{op1}, signed long int @var{op2})
@deftypefunx int mpfr_cmp_d (mpfr_t @var{op1}, double @var{op2})
Compare @var{op1} and @var{op2}.  Return a positive value if @math{@var{op1} >
@var{op2}}, zero if @math{@var{op1} = @var{op2}}, and a negative value if
@math{@var{op1} < @var{op2}}.
Both @var{op1} and @var{op2} are considered to their full own precision,
which may differ. In case @var{op1} and @var{op2} are of same sign but 
different, the absolute value returned is
one plus the absolute difference of their exponents.
It is not allowed that one of the operands is NaN (Not-a-Number).
@end deftypefun

@deftypefun int mpfr_cmp_ui_2exp (mpfr_t @var{op1}, unsigned long int @var{op2}, mp_exp_t @var{e})
@deftypefunx int mpfr_cmp_si_2exp (mpfr_t @var{op1}, long int @var{op2}, mp_exp_t @var{e})
Compare @var{op1} and @m{@var{op2} \times 2^e, @var{op2} multiplied by two to
the power @var{e}}.
@end deftypefun

@deftypefun int mpfr_cmpabs (mpfr_t @var{op1}, mpfr_t @var{op2})
Compare @math{|@var{op1}|} and @math{|@var{op2}|}.  Return a positive value if
@math{|@var{op1}| > |@var{op2}|}, zero if @math{|@var{op1}| = |@var{op2}|}, and
a negative value if @math{|@var{op1}| < |@var{op2}|}.
It is not allowed that one of the operands is NaN (Not-a-Number) or an
infinity.
@end deftypefun

@deftypefun int mpfr_eq (mpfr_t @var{op1}, mpfr_t @var{op2}, unsigned long int @var{op3})
Return non-zero if the first @var{op3} bits of @var{op1} and @var{op2} are
equal, zero otherwise.  I.e., tests if @var{op1} and @var{op2} are
approximately equal.
@end deftypefun

@deftypefun int mpfr_nan_p (mpfr_t @var{op})
Return non-zero if @var{op} is Not-a-Number (NaN), zero otherwise.
@end deftypefun

@deftypefun int mpfr_inf_p (mpfr_t @var{op})
Return non-zero if @var{op} is plus or minus infinity, zero otherwise.
@end deftypefun

@deftypefun int mpfr_number_p (mpfr_t @var{op})
Return non-zero if @var{op} is an ordinary number, i.e.@: neither Not-a-Number
nor plus or minus infinity.
@end deftypefun

@deftypefun void mpfr_reldiff (mpfr_t @var{rop}, mpfr_t @var{op1}, mpfr_t @var{op2}, mp_rnd_t @var{rnd})
Compute the relative difference between @var{op1} and @var{op2} 
and store the result in @var{rop}.
This function does not guarantee the exact rounding on the relative difference;
it just computes @math{|@var{op1}-@var{op2}|/@var{op1}}, using the
rounding mode @var{rnd} for all operations.
@end deftypefun

@deftypefn Macro int mpfr_sgn (mpfr_t @var{op})
Return a positive value if @math{@var{op} > 0}, zero if @math{@var{op} = 0},
and a negative value if @math{@var{op} < 0}.
Its result is undefined when @var{op} is NaN (Not-a-Number).

This function is actually implemented as a macro.  It evaluates its arguments
multiple times.
@end deftypefn

@node Special Functions, I/O of Floats, Float Comparison, Floating-point Functions
@section Special Functions
@cindex Special functions

@deftypefun int mpfr_log (mpfr_t @var{rop}, mpfr_t @var{op}, mp_rnd_t @var{rnd})
Set @var{rop} to the natural logarithm of @var{op},
rounded to the direction @var{rnd} with the precision of @var{rop}.
Return zero when the result is exact
(this occurs in fact only when @var{op} is 0, 1, or +infinity)
and a non-zero value otherwise (except for rounding to nearest,
the sign of the return value is that of @math{@var{rop}-@log{}(@var{op})}.
@end deftypefun

@deftypefun int mpfr_exp (mpfr_t @var{rop}, mpfr_t @var{op}, mp_rnd_t @var{rnd})
Set @var{rop} to the exponential of @var{op},
rounded to the direction @var{rnd} with the precision of @var{rop}.
Return zero when the result is exact
(this occurs in fact only when @var{op} is -infinity, 0, or +infinity),
a positive value when the result is greater than the exponential of @var{op},
and a negative value when it is smaller.
@end deftypefun

@deftypefun int mpfr_exp2 (mpfr_t @var{rop}, mpfr_t @var{op}, mp_rnd_t @var{rnd})
Set @var{rop} to @m{2^{op}, 2 power of @var{op}},
rounded to the direction @var{rnd} with the precision of @var{rop}.
Return zero iff the result is exact (this occurs in fact only when @var{op} 
is -infinity, 0, or +infinity),
a positive value when the result is greater than the exponential of @var{op},
and a negative value when it is smaller.
@end deftypefun

@deftypefun int mpfr_cos (mpfr_t @var{cop}, mpfr_t @var{op}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_sin (mpfr_t @var{sop}, mpfr_t @var{op}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_tan (mpfr_t @var{top}, mpfr_t @var{op}, mp_rnd_t @var{rnd})
Set @var{cop} to the cosine of @var{op}, @var{sop} to the sine of @var{op},
@var{top} to the tangent of @var{op}, rounded to the direction @var{rnd} with
the precision of @var{rop}. Return 0 iff the result is exact (this occurs
in fact only when @var{op} is 0 i.e.@: the sine is 0, the cosine is 1, and the
tangent is 0).
@end deftypefun

@deftypefun int mpfr_sin_cos (mpfr_t @var{sop}, mpfr_t @var{cop}, mpfr_t @var{op}, mp_rnd_t @var{rnd})
Set simultaneously @var{sop} to the sine of @var{op} and
                   @var{cop} to the cosine of @var{op},
rounded to the direction @var{rnd} with their corresponding precisions.
Return 0 iff both results are exact.
@end deftypefun

@deftypefun int mpfr_acos (mpfr_t @var{rop}, mpfr_t @var{op}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_asin (mpfr_t @var{rop}, mpfr_t @var{op}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_atan (mpfr_t @var{rop}, mpfr_t @var{op}, mp_rnd_t @var{rnd})
Set @var{rop} to the arc-cosine, arc-sine or arc-tangent of @var{op},
rounded to the direction @var{rnd} with the precision of @var{rop}.
Return 0 iff the result is exact.
@end deftypefun

@deftypefun int mpfr_cosh (mpfr_t @var{rop}, mpfr_t @var{op}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_sinh (mpfr_t @var{rop}, mpfr_t @var{op}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_tanh (mpfr_t @var{rop}, mpfr_t @var{op}, mp_rnd_t @var{rnd})
Set @var{rop} to the hyperbolic cosine, sine or tangent of @var{op},
rounded to the direction @var{rnd} with the precision of @var{rop}.
Return 0 iff the result is exact (this occurs in fact only when @var{op} is 0
or infinite).
@end deftypefun

@deftypefun int mpfr_acosh (mpfr_t @var{rop}, mpfr_t @var{op}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_asinh (mpfr_t @var{rop}, mpfr_t @var{op}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_atanh (mpfr_t @var{rop}, mpfr_t @var{op}, mp_rnd_t @var{rnd})
Set @var{rop} to the inverse hyperbolic cosine, sine or tangent of @var{op},
rounded to the direction @var{rnd} with the precision of @var{rop}.
Return 0 iff the result is exact.
@end deftypefun

@deftypefun int mpfr_fac_ui (mpfr_t @var{rop}, unsigned long int  @var{op}, mp_rnd_t @var{rnd})
Set @var{rop} to the factorial of the unsigned long int @var{op},
rounded to the direction @var{rnd} with the precision of @var{rop}.
Return 0 iff the result is exact.
@end deftypefun

@deftypefun int mpfr_log1p (mpfr_t @var{rop}, mpfr_t @var{op}, mp_rnd_t @var{rnd})
Set @var{rop} to the logarithm of one plus @var{op},
rounded to the direction @var{rnd} with the precision of @var{rop}.
Return 0 iff the result is exact (this occurs in fact only when @var{op} is 0
i.e.@: the result is 0).
@end deftypefun

@deftypefun int mpfr_expm1 (mpfr_t @var{rop}, mpfr_t @var{op}, mp_rnd_t @var{rnd})
Set @var{rop} to the exponential of @var{op} minus one,
rounded to the direction @var{rnd} with the precision of @var{rop}.
Return 0 iff the result is exact (this occurs in fact only when @var{op} is 0
i.e.@: the result is 0).
@end deftypefun

@deftypefun int mpfr_log2 (mpfr_t @var{rop}, mpfr_t @var{op}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_log10 (mpfr_t @var{rop}, mpfr_t @var{op}, mp_rnd_t @var{rnd})
Set @var{rop} to @m{\log_2 @var{op}, log2(@var{op})} or @m{\log_{10} @var{op},
log10(@var{op})}, respectively, rounded to the direction @var{rnd} with the
precision of @var{rop}. Return 0 iff the result is exact (this occurs
only when @var{op} is 1 for @code{mpfr_log10}, and a power of two for
@code{mpfr_log2}).
@end deftypefun

@deftypefun int mpfr_gamma (mpfr_t @var{rop}, mpfr_t @var{op}, mp_rnd_t @var{rnd})
Set @var{rop} to the value of the Gamma function on @var{op},
rounded to the direction @var{rnd} with the precision of @var{rop}.
Return 0 iff the result is exact.
@end deftypefun

@deftypefun void mpfr_zeta (mpfr_t @var{rop}, mpfr_t @var{op}, mp_rnd_t @var{rnd})
Set @var{rop} to the value of the Riemann Zeta function on @var{op},
rounded to the direction @var{rnd} with the precision of @var{rop}.
@end deftypefun

@deftypefun int mpfr_erf (mpfr_t @var{rop}, mpfr_t @var{op}, mp_rnd_t @var{rnd})
Set @var{rop} to the value of the error function on @var{op},
rounded to the direction @var{rnd} with the precision of @var{rop}.
Return 0 iff the result is exact (which only happens for plus or minus
infinity, and plus or minus zero).
@end deftypefun

@deftypefun int mpfr_fma (mpfr_t @var{rop}, mpfr_t @var{opx},mpfr_t @var{opy},mpfr_t @var{opz}, mp_rnd_t @var{rnd}) 
Set @var{rop} to @math{@var{opx} @GMPtimes{} @var{opy} + @var{opz}}, rounded to the direction 
@var{rnd} with the precision of @var{rop}. Return 0 iff the result is exact,
a positive value if @var{rop} is larger than @math{@var{opx} @GMPtimes{} @var{opy} + @var{opz}},
and a negative value otherwise.
@end deftypefun

@deftypefun int mpfr_agm (mpfr_t @var{rop}, mpfr_t @var{op1}, mpfr_t @var{op2}, mp_rnd_t @var{rnd})
Set @var{rop} to the arithmetic-geometric mean of @var{op1} and @var{op2},
rounded to the direction @var{rnd} with the precision of @var{rop}.
The arithmetic-geometric mean is the common limit of the sequences
u[n] and v[n], where u[0]=@var{op1}, v[0]=@var{op2}, u[n+1] is the
arithmetic mean of u[n] and v[n], and v[n+1] is the geometric mean of
u[n] and v[n].
Return 0 iff the result is exact.
@end deftypefun

@deftypefun void mpfr_const_log2 (mpfr_t @var{rop}, mp_rnd_t @var{rnd})
Set @var{rop} to the logarithm of 2 rounded to the direction @var{rnd}
with the precision of @var{rop}. This function stores the computed
value to avoid another calculation if a lower or equal precision is
requested.
@end deftypefun

@deftypefun void mpfr_const_pi (mpfr_t @var{rop}, mp_rnd_t @var{rnd})
Set @var{rop} to the value of @m{\pi,Pi} rounded to the direction @var{rnd}
with the precision of @var{rop}. This function uses the Plouffe, Bailey,
Borwein formula which directly gives the expansion of @m{\pi,Pi} in base 16.
@end deftypefun

@deftypefun void mpfr_const_euler (mpfr_t @var{rop}, mp_rnd_t @var{rnd})
Set @var{rop} to the value of Euler's constant 0.577@dots{}
rounded to the direction @var{rnd} with the precision of @var{rop}.
@end deftypefun

@node I/O of Floats, Miscellaneous Float Functions, Special Functions, Floating-point Functions
@comment  node-name,  next,  previous,  up
@section Input and Output Functions
@cindex Float input and output functions
@cindex Input functions
@cindex Output functions
@cindex I/O functions

Functions that perform input from a standard input/output
stream, and functions that output to
a standard input/output stream.
Passing a null pointer for a @var{stream} argument to any of
these functions will make them read from @code{stdin} and write to
@code{stdout}, respectively.

When using any of these functions, it is a good idea to include @file{stdio.h}
before @file{mpfr.h}, since that will allow @file{mpfr.h} to define prototypes
for these functions.

@deftypefun size_t mpfr_out_str (FILE *@var{stream}, int @var{base}, size_t @var{n_digits}, mpfr_t @var{op}, mp_rnd_t @var{rnd})
Output @var{op} on stdio stream @var{stream}, as a string of digits in
base @var{base}, rounded to direction @var{rnd}.
The base may vary from 2 to 36.  Print at most
@var{n_digits} significant digits, or if @var{n_digits} is 0, the maximum
number of digits accurately representable by @var{op}.

In addition to the significant digits, a decimal point at the right of the
first digit and a
trailing exponent, in the form @samp{eNNN}, are printed.  If @var{base}
is greater than 10, @samp{@@} will be used instead of @samp{e} as
exponent delimiter.

Return the number of bytes written, or if an error occurred, return 0.
@end deftypefun

@deftypefun size_t mpfr_inp_str (mpfr_t @var{rop}, FILE *@var{stream}, int @var{base}, mp_rnd_t @var{rnd})
Input a string in base @var{base} from stdio stream @var{stream},
rounded in direction @var{rnd}, and put the
read float in @var{rop}.  The string is of the form @samp{M@@N} or, if the
base is 10 or less, alternatively @samp{MeN} or @samp{MEN}, or, if the base
is 16, alternatively @samp{MpB} or @samp{MPB}.
@samp{M} is the mantissa in the specified base, @samp{N} is the exponent
written in decimal for the specified base, and in base 16, @samp{B} is the
binary exponent written in decimal (it indicates the power of 2 by which
the mantissa is to be scaled).
The argument @var{base} may be in the range 2 to 36.

Unlike the corresponding @code{mpz} function, the base will not be determined
from the leading characters of the string if @var{base} is 0.  This is so that
numbers like @samp{0.23} are not interpreted as octal.

Return the number of bytes read, or if an error occurred, return 0.
@end deftypefun

@deftypefun void mpfr_print_binary (mpfr_t @var{float})
Output @var{float} on stdout
in raw binary format (the exponent is in decimal, yet).
The last bits from the least significant limb which do not belong to
the mantissa are printed between square brackets;
they should always be zero.
@end deftypefun

@c @deftypefun void mpfr_inp_raw (mpfr_t @var{float}, FILE *@var{stream})
@c Input from stdio stream @var{stream} in the format written by
@c @code{mpfr_out_raw}, and put the result in @var{float}.
@c @end deftypefun

@node Miscellaneous Float Functions, Internals, I/O of Floats, Floating-point Functions
@comment  node-name,  next,  previous,  up
@section Miscellaneous Functions
@cindex Miscellaneous float functions

@deftypefun int mpfr_rint (mpfr_t @var{rop}, mpfr_t @var{op}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_ceil (mpfr_t @var{rop}, mpfr_t @var{op})
@deftypefunx int mpfr_floor (mpfr_t @var{rop}, mpfr_t @var{op})
@deftypefunx int mpfr_round (mpfr_t @var{rop}, mpfr_t @var{op})
@deftypefunx int mpfr_trunc (mpfr_t @var{rop}, mpfr_t @var{op})
Set @var{rop} to @var{op} rounded to an integer. @code{mpfr_ceil} rounds
to the next higher representable integer, @code{mpfr_floor} to the next lower,
@code{mpfr_round} to the nearest representable integer, rounding halfway cases
away from zero, and @code{mpfr_trunc} to the representable integer towards
zero. @code{mpfr_rint} behaves like one of these four functions, depending
on the rounding mode.
The returned value is zero when the result is exact, positive when it is
greater than the original value of @var{op}, and negative when it is smaller.
More precisely, the returned value is 0 when @var{op} is an integer
representable in @var{rop}, 1 or @minus{}1 when @var{op} is an integer
that is not representable in @var{rop}, 2 or @minus{}2 when @var{op} is
not an integer.
@end deftypefun

@deftypefun int mpfr_frac (mpfr_t @var{rop}, mpfr_t @var{op}, mp_rnd_t @var{rnd})
Set @var{rop} to the fractional part of @var{op}, having the same sign as
@var{op}.
The returned value is zero when the result is exact, positive when it is
greater than the exact value, and negative when it is smaller.
@end deftypefun

@deftypefun int mpfr_integer_p (mpfr_t @var{op})
Return non-zero iff @var{op} is an integer. 
@end deftypefun

@deftypefun int mpfr_fits_ulong_p (mpfr_t @var{op}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_fits_slong_p (mpfr_t @var{op}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_fits_uint_p (mpfr_t @var{op}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_fits_sint_p (mpfr_t @var{op}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_fits_ushort_p (mpfr_t @var{op}, mp_rnd_t @var{rnd})
@deftypefunx int mpfr_fits_sshort_p (mpfr_t @var{op}, mp_rnd_t @var{rnd})
Return non-zero if @var{op} would fit in the respective C data type, when
rounded to an integer.
@end deftypefun

@deftypefun void mpfr_nexttoward (mpfr_t @var{x}, mpfr_t @var{y})
If @var{x} or @var{y} is NaN, set @var{x} to NaN; the global invalid
flag is set too. Otherwise, if @var{x} is different from @var{y},
replace @var{x} by the next floating-point number (with the precision
of @var{x} and the current exponent range) in the direction of @var{y}
(the infinite values are seen as the smallest and largest floating-point
numbers). If the result is zero, it keeps the same sign. No underflow or
overflow is generated.
@end deftypefun

@deftypefun void mpfr_nextabove (mpfr_t @var{x})
Equivalent to @code{mpfr_nexttoward} where @var{y} is plus infinity.
@end deftypefun

@deftypefun void mpfr_nextbelow (mpfr_t @var{x})
Equivalent to @code{mpfr_nexttoward} where @var{y} is minus infinity.
@end deftypefun

@deftypefun void mpfr_urandomb (mpfr_t @var{rop}, gmp_randstate_t @var{state})
Generate a uniformly distributed random float in the interval 0 <= X < 1.
@end deftypefun

@deftypefun void mpfr_random (mpfr_t @var{rop})
Generate a uniformly distributed random float in the interval 0 <= X < 1.
@end deftypefun

@deftypefun void mpfr_random2 (mpfr_t @var{rop}, mp_size_t @var{max_size}, mp_exp_t @var{max_exp})
Generate a random float of at most @var{max_size} limbs, with long strings of
zeros and ones in the binary representation. The exponent of the number is in
the interval @minus{}@var{exp} to @var{exp}.
This function is useful for
testing functions and algorithms, since this kind of random numbers have
proven to be more likely to trigger corner-case bugs.  
Negative random numbers are generated when @var{max_size} is negative.
@end deftypefun

@c @deftypefun size_t mpfr_size (mpfr_t @var{op})
@c Return the size of @var{op} measured in number of limbs.  If @var{op} is
@c zero, the returned value will be zero.  (@xref{Nomenclature}, for an
@c explanation of the concept @dfn{limb}.)
@c
@c @strong{This function is obsolete.  It will disappear from future MP
@c releases.}
@c @end deftypefun

@node Internals,  , Miscellaneous Float Functions, Floating-point Functions
@section Internals
@cindex Internals

These types and 
functions were mainly designed for the implementation of @code{mpfr},
but may be useful for users too.
However no upward compatibility is guaranteed.
You may need to include @code{mpfr-impl.h} to use them.

The @code{mpfr_t} type consists of four fields.
The @code{_mpfr_prec} field is used to store the precision of
the variable (in bits); this is not less than 2.

The @code{_mpfr_size} field is used to store the number of
allocated limbs, with the high bits reserved to store
the sign (bit 31), the NaN flag (bit 30),
and the Infinity flag (bit 29);
thus bits 0 to 28 remain for the number of allocated limbs, with a maximal
value of 536870911.
A NaN is indicated by the NaN flag set, and the other fields are
undefined.
An Infinity is indicated by the NaN flag clear and the Inf flag set;
the sign bit of an Infinity indicates the sign, the limb data 
and the exponent are undefined.

The @code{_mpfr_exp} field stores the exponent.
An exponent of 0 means a radix point just above the most significant
limb.  Non-zero values are a multiplier @math{2^n} relative to that
point.

Finally, the @code{_mpfr_d} is a pointer to the limbs, least
significant limbs stored first.
The number of limbs in use is controlled by @code{_mpfr_prec}, namely
ceil(@code{_mpfr_prec}/@code{BITS_PER_MP_LIMB}).
Zeros are represented by the most significant limb being zero, other
limb data and the exponent are undefined (this implies that the
corresponding objects may contain invalid values, thus should not be
evaluated even if they are not taken into account).
Non-zero values always have the most significant bit of the most
significant limb set to 1.  When the precision is not a whole number
of limbs, the excess bits at the low end of the data are zero.
When the precision has been lowered by @code{mpfr_set_prec}, the space
allocated at @code{_mpfr_d} remains as given by @code{_mpfr_size}, but
@code{_mpfr_prec} indicates how much of that space is actually used.

@deftypefun int mpfr_add_one_ulp (mpfr_t @var{x}, mp_rnd_t @var{rnd})
Add one unit in last place (ulp) to @var{x} if @var{x} is finite
and positive, subtract one ulp if @var{x} is finite and negative;
otherwise, @var{x} is not changed.
The return value is zero unless an overflow occurs, in which case the
@code{mpfr_add_one_ulp} function behaves like a conventional addition.
@end deftypefun

@deftypefun int mpfr_sub_one_ulp (mpfr_t @var{x}, mp_rnd_t @var{rnd})
Subtract one ulp to @var{x} if @var{x} is finite and positive, add one
ulp if @var{x} is finite and negative; otherwise, @var{x} is not changed.
The return value is zero unless an underflow occurs, in which case the
@code{mpfr_sub_one_ulp} function behaves like a conventional subtraction.
@end deftypefun

@deftypefun int mpfr_can_round (mpfr_t @var{b}, mp_exp_t @var{err}, mp_rnd_t @var{rnd1}, mp_rnd_t @var{rnd2}, mp_prec_t @var{prec})
Assuming @var{b} is an approximation of an unknown number
@var{x} in direction @var{rnd1} with error at most two to the power 
E(b)-@var{err} where E(b) is the exponent of 
@var{b}, returns 1 if one is able to round exactly @var{x} to precision 
@var{prec} with direction @var{rnd2},
   and 0 otherwise. This function @strong{does not modify} its arguments.
@end deftypefun

@deftypefun mp_exp_t mpfr_get_exp (mpfr_srcptr @var{x})
Get the exponent of @var{x}, assuming that @var{x} is a non-zero real
number.
@end deftypefun

@deftypefun int mpfr_set_exp (mpfr_ptr @var{x}, mp_exp_t @var{e})
Set the exponent of @var{x} if @var{e} is in the current exponent range,
and return 0; otherwise, return 1. If @var{x} is not a real number or is
equal to zero, nothing visible happens.
@end deftypefun

@node Contributors, References, Floating-point Functions, Top
@comment  node-name,  next,  previous,  up
@unnumbered Contributors

The main developers consist of Guillaume Hanrot, Vincent Lefvre and
Paul Zimmermann.

We would like to thank Jean-Michel Muller and Joris van der Hoeven for very
fruitful discussions at the beginning of that project, Torbjorn Granlund
and Kevin Ryde
for their help about design issues 
and their suggestions for an easy integration into GNU MP,
and Nathalie Revol for her careful reading of this documentation.

Sylvie Boldo from ENS-Lyon, France,
contributed the functions @code{mpfr_agm} and @code{mpfr_log}.
Emmanuel Jeandel, from ENS-Lyon too,
contributed the generic hypergeometric code in
@code{generic.c}, as well as the @code{mpfr_exp3},
a first implementation of the sine and cosine,
and improved versions of
@code{mpfr_const_log2} and @code{mpfr_const_pi}.
Mathieu Dutour contributed the functions @code{mpfr_atan} and @code{mpfr_asin},
David Daney contributed the hyperbolic and inverse hyperbolic functions,
the base-2 exponential, and the factorial function. Fabrice Rouillier
contributed the original version of @file{mul_ui.c}, the @file{gmp_op.c}
file, and helped to the Windows porting.
Jean-Luc Rmy contributed the @code{mpfr_zeta} code.

@node References, GNU Free Documentation License, Contributors, Top
@comment  node-name,  next,  previous,  up
@unnumbered References

@itemize @bullet

@item
Torbjorn Granlund, "GNU MP: The GNU Multiple Precision Arithmetic Library", 
  version 4.0.1, 2002.

@item
IEEE standard for binary floating-point arithmetic, Technical Report 
ANSI-IEEE Standard 754-1985, New York, 1985.
Approved March 21, 1985: IEEE Standards Board; approved July 26,
  1985: American National Standards Institute, 18 pages.

@item
Donald E. Knuth, "The Art of Computer Programming", vol 2,
"Seminumerical Algorithms", 2nd edition, Addison-Wesley, 1981.

@end itemize


@node GNU Free Documentation License, Concept Index, References, Top
@appendix GNU Free Documentation License
@cindex GNU Free Documentation License
@include fdl.texi


@node Concept Index, Function Index, GNU Free Documentation License, Top
@comment  node-name,  next,  previous,  up
@unnumbered Concept Index
@printindex cp

@node Function Index,  , Concept Index, Top
@comment  node-name,  next,  previous,  up
@unnumbered Function and Type Index
@printindex fn

@bye

@c Local variables:
@c fill-column: 78
@c End:
